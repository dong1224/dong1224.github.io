# qom源码分析

QOM是QEMU在C的基础上自己实现的一套面向对象机制，负责将device、bus等设备都抽象成为对象。对象的初始化分为四步：

- 将 TypeInfo 注册 TypeImpl
- 实例化 ObjectClass
- 实例化 Object
- 添加 Property

根据QEMU的 wiki ，QOM没有构造和析构的概念。但矛盾的是根据代码， 
TypeInfo 中定义的 class_init 和 instance_init 无论从名字还是实现上都做了对象的初始化工作，
比如设置对象成员的值。但为什么说它们最多只能算是初始化函数呢？

	Everything in QOM is a device

根据实现，经过 class_init 和 instance_init 产生设备对应Object后，这个Object是不能直接使用的。
其真正初始化逻辑的大头都放在 realize 中做，比如创建对应的memory region，挂载到对应bus上等等。只有在 realize 后，
设备才算真正构造完成，可以拿来用了。因此QEMU认为，类似构造和析构的是realize和unrealize。而在设备的生命周期中，
可以被realize和unrealize多次。这也是最让我莫名其妙的地方。

main函数一进来，就会做module_init，之所以这样做是因为c并没有class的概念，需要提前定义这些type（相当于面向对象中的定义class）。
把各种type的继承关系树形结构先建立起来。module_init(function, MODULE_INIT_QOM)。这里创建的是qom，
当然还有其它module会创建，这个以后再分析。

	void register_module_init(void (*fn)(void), module_init_type type)
	{
		ModuleEntry *e;
		ModuleTypeList *l;

		e = g_malloc0(sizeof(*e));
		e->init = fn;
		e->type = type;

		l = find_type(type);

		QTAILQ_INSERT_TAIL(l, e, node);
	}
	
同时将该 TypeImpl 注册到全局 type_table 中，key为类型名称。

## TypeImpl => ObjectClass


QEMU学习笔记——QOM(Qemu Object Model)
2017-07-17 22:59
本文发自 http://www.binss.me/blog/qemu-note-of-qemu-object-model/，转载请注明出处。

QOM(Qemu Object Model)是QEMU最新的设备模型。QEMU一开始采用ad hoc，每种设备都有不同的表示方式，非常混乱。于是开发了qdev，将所有的模拟设备进行了整合，变成了一种单根结点(系统总线)的树状形式，并且增加了hotplug的功能。后来可能由于Device和Bus之间的复杂关系，又开发了QOM。

QOM是QEMU在C的基础上自己实现的一套面向对象机制，负责将device、bus等设备都抽象成为对象。对象的初始化分为四步：

将 TypeInfo 注册 TypeImpl
实例化 ObjectClass
实例化 Object
添加 Property
根据QEMU的 wiki ，QOM没有构造和析构的概念。但矛盾的是根据代码， TypeInfo 中定义的 class_init 和 instance_init 无论从名字还是实现上都做了对象的初始化工作，比如设置对象成员的值。但为什么说它们最多只能算是初始化函数呢？

Everything in QOM is a device

根据实现，经过 class_init 和 instance_init 产生设备对应Object后，这个Object是不能直接使用的。其真正初始化逻辑的大头都放在 realize 中做，比如创建对应的memory region，挂载到对应bus上等等。只有在 realize 后，设备才算真正构造完成，可以拿来用了。因此QEMU认为，类似构造和析构的是realize和unrealize。而在设备的生命周期中，可以被realize和unrealize多次。这也是最让我莫名其妙的地方。

为了保持习惯，本文会依然将 class_init 和 instance_init 当做构造函数，称前者为类构造函数，后者为类实例构造函数。

TypeInfo => ModuleEntry
TypeInfo 定义了一种类型。如 KVM在kvm-all.c中的定义：

static const TypeInfo kvm_accel_type = {
    .name = TYPE_KVM_ACCEL,
    .parent = TYPE_ACCEL,
    .class_init = kvm_accel_class_init,
    .instance_size = sizeof(KVMState),
};
包含 类型的名称(name)、父类名称(parent)、Object实例的大小(instance_size)、是否抽象类(abstract)、初始化函数(class_init)。

代码底部有 type_init ，由 C run-time(CRT)负责执行：

type_init(kvm_type_init) => module_init(function, MODULE_INIT_QOM) => register_module_init(function, type)

void register_module_init(void (*fn)(void), module_init_type type)
{
    ModuleEntry *e;
    ModuleTypeList *l;

    e = g_malloc0(sizeof(*e));
    e->init = fn;
    e->type = type;

    l = find_type(type);

    QTAILQ_INSERT_TAIL(l, e, node);
}
创建了 type 为 MODULE_INIT_QOM ，init为 kvm_type_init 的 ModuleEntry ，并加入到 MODULE_INIT_QOM 的 ModuleTypeList 中。

ModuleEntry => TypeImpl
在 main.c(vl.c) 的一开始执行了 module_call_init(MODULE_INIT_QOM) ，它从 init_type_list 中取出对应的 ModuleTypeList ，然后对里面的 ModuleEntry 成员都调用 init 函数。

对于上文提到的 ModuleEntry ，调用的是 kvm_type_init => type_register_static(&kvm_accel_type) => type_register => type_register_internal

static TypeImpl *type_register_internal(const TypeInfo *info)
{
    TypeImpl *ti;
    ti = type_new(info);

    type_table_add(ti);
    return ti;
}
它根据 kvm_accel_type(TypeInfo) 创建一个名为TYPE_KVM_ACCEL的 TypeImpl 类型的结构。

同时将该 TypeImpl 注册到全局 type_table 中，key为类型名称，即 TYPE_KVM_ACCEL

ObjectClass
struct ObjectClass
{
    /*< private >*/
    Type type;              // 用typedef定义的 TypeImpl 指针
    GSList *interfaces;

    const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE];
    const char *class_cast_cache[OBJECT_CLASS_CAST_CACHE];

    ObjectUnparent *unparent;

    GHashTable *properties;
};
ObjectClass 属于类对象，它是所有类对象的基类。

## TypeImpl => ObjectClass

有两种路径，一种是主动地调用： 
object_class_get_list => object_class_foreach => g_hash_table_foreach(object_class_foreach_tramp) => object_class_foreach_tramp => type_initialize
这里是通过TypeImpl获取到ObjectClass列表，也就是说一个TypeImpl要对应多个类。

比如 object_class_get_list(TYPE_DEVICE, false) 创建 TYPE_DEVICE 类型的 ObjectClass

另一种是被动调用，如：

- object_class_by_name  //通过typename可以获得唯一的ObjectClass
- object_class_get_parent  //ObjectClass有唯一的父亲

那么问题来了。TypeImpl和typename又是什么关系呢？

在获取 class、class的parent、创建type的object、初始化TypeImpl的object时，调用 type_initialize